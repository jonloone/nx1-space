<!DOCTYPE html>
<html>
<head>
  <title>Cesium Ion Token Diagnostic</title>
  <script>window.CESIUM_BASE_URL = '/cesium/';</script>
  <script src="/cesium/Cesium.js"></script>
  <link href="/cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      margin: 0; 
      padding: 20px;
      background: #1a1a1a;
      color: #fff;
    }
    .container { max-width: 1200px; margin: 0 auto; }
    h1 { color: #00d4ff; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
    .panel { 
      background: #2a2a2a; 
      border: 1px solid #444; 
      border-radius: 8px; 
      padding: 15px;
    }
    .panel h3 { 
      margin-top: 0; 
      color: #00d4ff;
      border-bottom: 1px solid #444;
      padding-bottom: 10px;
    }
    #cesiumContainer { 
      width: 100%; 
      height: 500px; 
      border: 2px solid #00d4ff; 
      border-radius: 8px;
      margin: 20px 0;
    }
    .status-item {
      padding: 8px;
      margin: 5px 0;
      border-radius: 4px;
      font-size: 14px;
    }
    .success { background: #1e4d2b; color: #4ade80; }
    .error { background: #4d1e1e; color: #f87171; }
    .warning { background: #4d3d1e; color: #fbbf24; }
    .info { background: #1e3a4d; color: #60a5fa; }
    .metric { 
      display: flex; 
      justify-content: space-between; 
      padding: 8px 0; 
      border-bottom: 1px solid #333;
    }
    .metric-label { color: #888; }
    .metric-value { color: #fff; font-weight: bold; }
    button {
      background: #00d4ff;
      color: #000;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      margin: 5px;
    }
    button:hover { background: #00a8cc; }
    #networkLog {
      max-height: 300px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 12px;
    }
    .log-entry {
      padding: 4px;
      border-bottom: 1px solid #333;
    }
    .log-success { color: #4ade80; }
    .log-error { color: #f87171; }
    .log-pending { color: #fbbf24; }
    pre { 
      background: #1a1a1a; 
      padding: 10px; 
      border-radius: 4px; 
      overflow-x: auto;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üîç Cesium Ion Token Diagnostic Tool</h1>
    
    <div class="grid">
      <div class="panel">
        <h3>üìä Token Configuration</h3>
        <div id="tokenStatus"></div>
      </div>
      
      <div class="panel">
        <h3>üåê Network Metrics</h3>
        <div id="networkMetrics"></div>
      </div>
    </div>

    <div class="panel">
      <h3>üéÆ Test Controls</h3>
      <button onclick="testBasicAuth()">Test Basic Authentication</button>
      <button onclick="testTerrainAccess()">Test Terrain Access</button>
      <button onclick="testImageryAccess()">Test Imagery Access</button>
      <button onclick="testAssetList()">List Available Assets</button>
      <button onclick="createFullViewer()">Create Full 3D Viewer</button>
      <button onclick="clearLogs()">Clear Logs</button>
    </div>

    <div id="cesiumContainer"></div>

    <div class="grid">
      <div class="panel">
        <h3>üì° Network Log</h3>
        <div id="networkLog"></div>
      </div>
      
      <div class="panel">
        <h3>üîß Diagnostic Results</h3>
        <div id="diagnosticResults"></div>
      </div>
    </div>
  </div>

  <script>
    // Your token
    const TOKEN = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI5MDgxNDg3ZS01Mjc4LTQyYmUtOTExMi1kNjM3ODNiYzhhOTUiLCJpZCI6MzMxNjgwLCJpYXQiOjE3NTUwOTk5MDV9.E4s_kL0HClK1eRmDipNDzg4EDEBhi4MPJK679FnWXSE';
    
    let viewer = null;
    let networkRequests = [];
    let diagnosticInfo = {};

    // Initialize
    window.addEventListener('load', () => {
      initializeDiagnostics();
      monitorNetwork();
    });

    function initializeDiagnostics() {
      const tokenStatus = document.getElementById('tokenStatus');
      
      if (typeof Cesium === 'undefined') {
        addStatus(tokenStatus, '‚ùå Cesium library not loaded', 'error');
        return;
      }
      
      addStatus(tokenStatus, '‚úÖ Cesium library loaded', 'success');
      
      // Set and validate token
      Cesium.Ion.defaultAccessToken = TOKEN;
      addStatus(tokenStatus, '‚úÖ Token set in Cesium.Ion', 'success');
      
      // Parse JWT token
      try {
        const tokenParts = TOKEN.split('.');
        const payload = JSON.parse(atob(tokenParts[1]));
        
        diagnosticInfo.tokenId = payload.jti;
        diagnosticInfo.userId = payload.id;
        diagnosticInfo.issuedAt = new Date(payload.iat * 1000).toISOString();
        
        addStatus(tokenStatus, `User ID: ${payload.id}`, 'info');
        addStatus(tokenStatus, `Token ID: ${payload.jti.substring(0, 8)}...`, 'info');
        addStatus(tokenStatus, `Issued: ${new Date(payload.iat * 1000).toLocaleDateString()}`, 'info');
        
        // Check if token might be expired (tokens typically last 1 year)
        const tokenAge = Date.now() - (payload.iat * 1000);
        const daysOld = tokenAge / (1000 * 60 * 60 * 24);
        
        if (daysOld > 365) {
          addStatus(tokenStatus, `‚ö†Ô∏è Token is ${Math.floor(daysOld)} days old - may be expired`, 'warning');
        } else {
          addStatus(tokenStatus, `‚úÖ Token age: ${Math.floor(daysOld)} days`, 'success');
        }
      } catch (e) {
        addStatus(tokenStatus, '‚ö†Ô∏è Could not parse token', 'warning');
      }
      
      updateNetworkMetrics();
    }

    function monitorNetwork() {
      // Override fetch to monitor requests
      const originalFetch = window.fetch;
      window.fetch = function(...args) {
        const url = args[0];
        const startTime = performance.now();
        
        if (url.includes('cesium.com') || url.includes('ion')) {
          const requestId = Date.now();
          logNetwork(`üîÑ [${requestId}] ${url.substring(0, 80)}...`, 'pending');
        }
        
        return originalFetch.apply(this, args)
          .then(response => {
            const endTime = performance.now();
            const duration = Math.round(endTime - startTime);
            
            if (url.includes('cesium.com') || url.includes('ion')) {
              networkRequests.push({
                url: url,
                status: response.status,
                duration: duration,
                ok: response.ok,
                timestamp: new Date().toISOString()
              });
              
              if (response.ok) {
                logNetwork(`‚úÖ ${response.status} (${duration}ms) ${url.substring(0, 60)}...`, 'success');
              } else {
                logNetwork(`‚ùå ${response.status} (${duration}ms) ${url.substring(0, 60)}...`, 'error');
                
                // Log specific error types
                if (response.status === 401) {
                  addDiagnostic('üîë 401 Unauthorized - Token not valid for this resource', 'error');
                } else if (response.status === 403) {
                  addDiagnostic('üîí 403 Forbidden - Token expired or insufficient permissions', 'error');
                } else if (response.status === 404) {
                  addDiagnostic('‚ùì 404 Not Found - Asset or tile not available', 'warning');
                }
              }
              
              updateNetworkMetrics();
            }
            
            return response;
          })
          .catch(error => {
            if (url.includes('cesium.com') || url.includes('ion')) {
              logNetwork(`üí• Network Error: ${error.message}`, 'error');
              addDiagnostic(`Network error: ${error.message}`, 'error');
            }
            throw error;
          });
      };
    }

    function updateNetworkMetrics() {
      const metrics = document.getElementById('networkMetrics');
      metrics.innerHTML = '';
      
      const totalRequests = networkRequests.length;
      const successfulRequests = networkRequests.filter(r => r.ok).length;
      const failedRequests = networkRequests.filter(r => !r.ok).length;
      const avgDuration = totalRequests > 0 
        ? Math.round(networkRequests.reduce((sum, r) => sum + r.duration, 0) / totalRequests)
        : 0;
      
      addMetric(metrics, 'Total Requests', totalRequests);
      addMetric(metrics, 'Successful', successfulRequests);
      addMetric(metrics, 'Failed', failedRequests);
      addMetric(metrics, 'Success Rate', totalRequests > 0 ? `${Math.round(successfulRequests/totalRequests*100)}%` : 'N/A');
      addMetric(metrics, 'Avg Response Time', `${avgDuration}ms`);
      
      // Count by status code
      const statusCodes = {};
      networkRequests.forEach(r => {
        statusCodes[r.status] = (statusCodes[r.status] || 0) + 1;
      });
      
      Object.entries(statusCodes).forEach(([code, count]) => {
        addMetric(metrics, `HTTP ${code}`, count);
      });
    }

    async function testBasicAuth() {
      addDiagnostic('Testing basic authentication...', 'info');
      
      try {
        const response = await fetch(`https://api.cesium.com/v1/assets`, {
          headers: {
            'Authorization': `Bearer ${TOKEN}`
          }
        });
        
        if (response.ok) {
          const data = await response.json();
          addDiagnostic(`‚úÖ Authentication successful! Found ${data.items ? data.items.length : 0} assets`, 'success');
        } else {
          addDiagnostic(`‚ùå Authentication failed: ${response.status} ${response.statusText}`, 'error');
        }
      } catch (error) {
        addDiagnostic(`‚ùå Authentication test failed: ${error.message}`, 'error');
      }
    }

    async function testTerrainAccess() {
      addDiagnostic('Testing Cesium World Terrain access...', 'info');
      
      try {
        const terrainProvider = await Cesium.CesiumTerrainProvider.fromIonAssetId(1);
        addDiagnostic('‚úÖ Terrain provider created successfully', 'success');
        
        // Test loading a specific tile
        const tilingScheme = terrainProvider.tilingScheme;
        const availability = terrainProvider.availability;
        
        addDiagnostic(`Tiling Scheme: ${tilingScheme.constructor.name}`, 'info');
        addDiagnostic(`Has water mask: ${terrainProvider.hasWaterMask}`, 'info');
        addDiagnostic(`Has vertex normals: ${terrainProvider.hasVertexNormals}`, 'info');
        
      } catch (error) {
        addDiagnostic(`‚ùå Terrain access failed: ${error.message}`, 'error');
      }
    }

    async function testImageryAccess() {
      addDiagnostic('Testing Cesium World Imagery access...', 'info');
      
      try {
        const imageryProvider = await Cesium.IonImageryProvider.fromAssetId(3);
        addDiagnostic('‚úÖ Imagery provider created successfully', 'success');
        
        addDiagnostic(`Min level: ${imageryProvider.minimumLevel}`, 'info');
        addDiagnostic(`Max level: ${imageryProvider.maximumLevel}`, 'info');
        addDiagnostic(`Tile width: ${imageryProvider.tileWidth}`, 'info');
        addDiagnostic(`Tile height: ${imageryProvider.tileHeight}`, 'info');
        
      } catch (error) {
        addDiagnostic(`‚ùå Imagery access failed: ${error.message}`, 'error');
      }
    }

    async function testAssetList() {
      addDiagnostic('Fetching available Ion assets...', 'info');
      
      try {
        // Test common asset IDs
        const commonAssets = [
          { id: 1, name: 'Cesium World Terrain' },
          { id: 2, name: 'Cesium World Imagery' },
          { id: 3, name: 'Bing Maps Aerial' },
          { id: 4, name: 'Bing Maps Aerial with Labels' }
        ];
        
        for (const asset of commonAssets) {
          try {
            await Cesium.IonResource.fromAssetId(asset.id);
            addDiagnostic(`‚úÖ Asset ${asset.id}: ${asset.name} - Accessible`, 'success');
          } catch (e) {
            addDiagnostic(`‚ùå Asset ${asset.id}: ${asset.name} - Not accessible`, 'error');
          }
        }
        
      } catch (error) {
        addDiagnostic(`‚ùå Asset list test failed: ${error.message}`, 'error');
      }
    }

    async function createFullViewer() {
      addDiagnostic('Creating full Cesium viewer...', 'info');
      
      // Destroy existing viewer if any
      if (viewer && !viewer.isDestroyed()) {
        viewer.destroy();
      }
      
      try {
        // Try with Ion services first
        const terrainProvider = await Cesium.CesiumTerrainProvider.fromIonAssetId(1);
        
        viewer = new Cesium.Viewer('cesiumContainer', {
          terrainProvider: terrainProvider,
          baseLayerPicker: true,
          imageryProvider: await Cesium.IonImageryProvider.fromAssetId(3),
          geocoder: false,
          homeButton: true,
          sceneModePicker: true,
          navigationHelpButton: false,
          animation: false,
          timeline: false,
          fullscreenButton: false
        });
        
        addDiagnostic('‚úÖ Viewer created with Ion services', 'success');
        
        // Set initial view
        viewer.camera.setView({
          destination: Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883, 1000000)
        });
        
        // Monitor tile loading
        let tileCount = 0;
        viewer.scene.globe.tileLoadProgressEvent.addEventListener((queueLength) => {
          if (queueLength > 0) {
            tileCount++;
            if (tileCount % 10 === 0) {
              addDiagnostic(`Loading tiles... (${queueLength} in queue)`, 'info');
            }
          }
        });
        
      } catch (error) {
        addDiagnostic(`‚ö†Ô∏è Ion services failed, using fallback: ${error.message}`, 'warning');
        
        // Fallback to non-Ion services
        try {
          viewer = new Cesium.Viewer('cesiumContainer', {
            terrainProvider: new Cesium.EllipsoidTerrainProvider(),
            imageryProvider: new Cesium.OpenStreetMapImageryProvider({
              url: 'https://a.tile.openstreetmap.org/'
            }),
            baseLayerPicker: false,
            geocoder: false,
            homeButton: true,
            sceneModePicker: true,
            navigationHelpButton: false,
            animation: false,
            timeline: false,
            fullscreenButton: false
          });
          
          addDiagnostic('‚úÖ Viewer created with fallback providers', 'success');
        } catch (fallbackError) {
          addDiagnostic(`‚ùå Viewer creation failed: ${fallbackError.message}`, 'error');
        }
      }
    }

    function clearLogs() {
      document.getElementById('networkLog').innerHTML = '';
      document.getElementById('diagnosticResults').innerHTML = '';
      networkRequests = [];
      updateNetworkMetrics();
    }

    // Helper functions
    function addStatus(container, message, className) {
      const div = document.createElement('div');
      div.className = `status-item ${className}`;
      div.textContent = message;
      container.appendChild(div);
    }

    function addMetric(container, label, value) {
      const div = document.createElement('div');
      div.className = 'metric';
      div.innerHTML = `
        <span class="metric-label">${label}:</span>
        <span class="metric-value">${value}</span>
      `;
      container.appendChild(div);
    }

    function logNetwork(message, type) {
      const log = document.getElementById('networkLog');
      const entry = document.createElement('div');
      entry.className = `log-entry log-${type}`;
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      log.insertBefore(entry, log.firstChild);
      
      // Keep only last 50 entries
      while (log.children.length > 50) {
        log.removeChild(log.lastChild);
      }
    }

    function addDiagnostic(message, type) {
      const results = document.getElementById('diagnosticResults');
      const div = document.createElement('div');
      div.className = `status-item ${type}`;
      div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      results.insertBefore(div, results.firstChild);
    }
  </script>
</body>
</html>