
function $parcel$defineInteropFlag(a) {
  Object.defineProperty(a, '__esModule', {value: true, configurable: true});
}

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $009ddb00d3ec72b8$exports = {};

$parcel$defineInteropFlag($009ddb00d3ec72b8$exports);

$parcel$export($009ddb00d3ec72b8$exports, "default", () => $009ddb00d3ec72b8$export$2e2bcd8739ae039);
class $009ddb00d3ec72b8$export$2e2bcd8739ae039 extends Error {
    constructor(filename, msg, lineno, column, css){
        super(filename + ':' + lineno + ':' + column + ': ' + msg);
        this.reason = msg;
        this.filename = filename;
        this.line = lineno;
        this.column = column;
        this.source = css;
    }
}


var $0865a9fb4cc365fe$exports = {};

$parcel$defineInteropFlag($0865a9fb4cc365fe$exports);

$parcel$export($0865a9fb4cc365fe$exports, "default", () => $0865a9fb4cc365fe$export$2e2bcd8739ae039);
/**
 * Store position information for a node
 */ class $0865a9fb4cc365fe$export$2e2bcd8739ae039 {
    constructor(start, end, source){
        this.start = start;
        this.end = end;
        this.source = source;
    }
}


var $b2e137848b48cf4f$exports = {};

$parcel$export($b2e137848b48cf4f$exports, "CssTypes", () => $b2e137848b48cf4f$export$9be5dd6e61d5d73a);
var $b2e137848b48cf4f$export$9be5dd6e61d5d73a = /*#__PURE__*/ function(CssTypes) {
    CssTypes["stylesheet"] = "stylesheet";
    CssTypes["rule"] = "rule";
    CssTypes["declaration"] = "declaration";
    CssTypes["comment"] = "comment";
    CssTypes["container"] = "container";
    CssTypes["charset"] = "charset";
    CssTypes["document"] = "document";
    CssTypes["customMedia"] = "custom-media";
    CssTypes["fontFace"] = "font-face";
    CssTypes["host"] = "host";
    CssTypes["import"] = "import";
    CssTypes["keyframes"] = "keyframes";
    CssTypes["keyframe"] = "keyframe";
    CssTypes["layer"] = "layer";
    CssTypes["media"] = "media";
    CssTypes["namespace"] = "namespace";
    CssTypes["page"] = "page";
    CssTypes["startingStyle"] = "starting-style";
    CssTypes["supports"] = "supports";
    return CssTypes;
}({});


const $6d129ebf064c486f$export$82eb5486fce3d340 = 10000;
const $6d129ebf064c486f$export$c8b95ffeec50f24a = (string, search, position)=>{
    let currentPosition = position;
    let maxLoop = $6d129ebf064c486f$export$82eb5486fce3d340;
    do {
        const all = search.map((v)=>string.indexOf(v, currentPosition));
        all.push(string.indexOf('\\', currentPosition));
        const foundAll = all.filter((v)=>v !== -1);
        if (foundAll.length === 0) return -1;
        const found = Math.min(...foundAll);
        if (string[found] === '\\') {
            currentPosition = found + 2;
            maxLoop--;
        } else return found;
    }while (maxLoop > 0);
    throw new Error('Too many escaping');
};
const $6d129ebf064c486f$export$b8d42a8583d2e477 = (string, search, position)=>{
    let currentSearchPosition = position;
    let maxLoop = $6d129ebf064c486f$export$82eb5486fce3d340;
    do {
        const all = search.map((v)=>string.indexOf(v, currentSearchPosition));
        all.push(string.indexOf('(', currentSearchPosition));
        all.push(string.indexOf('"', currentSearchPosition));
        all.push(string.indexOf("'", currentSearchPosition));
        all.push(string.indexOf('\\', currentSearchPosition));
        const foundAll = all.filter((v)=>v !== -1);
        if (foundAll.length === 0) return -1;
        const firstMatchPos = Math.min(...foundAll);
        const char = string[firstMatchPos];
        switch(char){
            case '\\':
                currentSearchPosition = firstMatchPos + 2;
                break;
            case '(':
                {
                    const endPosition = $6d129ebf064c486f$export$b8d42a8583d2e477(string, [
                        ')'
                    ], firstMatchPos + 1);
                    if (endPosition === -1) return -1;
                    currentSearchPosition = endPosition + 1;
                }
                break;
            case '"':
                {
                    const endQuotePosition = $6d129ebf064c486f$export$c8b95ffeec50f24a(string, [
                        '"'
                    ], firstMatchPos + 1);
                    if (endQuotePosition === -1) return -1;
                    currentSearchPosition = endQuotePosition + 1;
                }
                break;
            case "'":
                {
                    const endQuotePosition = $6d129ebf064c486f$export$c8b95ffeec50f24a(string, [
                        "'"
                    ], firstMatchPos + 1);
                    if (endQuotePosition === -1) return -1;
                    currentSearchPosition = endQuotePosition + 1;
                }
                break;
            default:
                return firstMatchPos;
        }
        maxLoop--;
    }while (maxLoop > 0);
    throw new Error('Too many escaping');
};
const $6d129ebf064c486f$export$801dd37ac183521b = (string, search)=>{
    const result = [];
    let currentPosition = 0;
    while(currentPosition < string.length){
        const index = $6d129ebf064c486f$export$b8d42a8583d2e477(string, search, currentPosition);
        if (index === -1) {
            result.push(string.substring(currentPosition));
            return result;
        }
        result.push(string.substring(currentPosition, index));
        currentPosition = index + 1;
    }
    return result;
};


// http://www.w3.org/TR/CSS21/grammar.html
// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
// New rule => https://www.w3.org/TR/CSS22/syndata.html#comments
// [^] is equivalent to [.\n\r]
const $d708735ed1303b43$var$commentre = /\/\*[^]*?(?:\*\/|$)/g;
const $d708735ed1303b43$export$98e6a39c04603d36 = (css, options)=>{
    options = options || {};
    /**
   * Positional.
   */ let lineno = 1;
    let column = 1;
    /**
   * Update lineno and column based on `str`.
   */ function updatePosition(str) {
        const lines = str.match(/\n/g);
        if (lines) lineno += lines.length;
        const i = str.lastIndexOf('\n');
        column = ~i ? str.length - i : column + str.length;
    }
    /**
   * Mark position and patch `node.position`.
   */ function position() {
        const start = {
            line: lineno,
            column: column
        };
        return function(node) {
            node.position = new (0, $0865a9fb4cc365fe$export$2e2bcd8739ae039)(start, {
                line: lineno,
                column: column
            }, options?.source || '');
            whitespace();
            return node;
        };
    }
    /**
   * Error `msg`.
   */ const errorsList = [];
    function error(msg) {
        const err = new (0, $009ddb00d3ec72b8$export$2e2bcd8739ae039)(options?.source || '', msg, lineno, column, css);
        if (options?.silent) errorsList.push(err);
        else throw err;
    }
    /**
   * Parse stylesheet.
   */ function stylesheet() {
        const rulesList = rules();
        const result = {
            type: (0, $b2e137848b48cf4f$export$9be5dd6e61d5d73a).stylesheet,
            stylesheet: {
                source: options?.source,
                rules: rulesList,
                parsingErrors: errorsList
            }
        };
        return result;
    }
    /**
   * Opening brace.
   */ function open() {
        const openMatch = /^{\s*/.exec(css);
        if (openMatch) {
            processMatch(openMatch);
            return true;
        }
        return false;
    }
    /**
   * Closing brace.
   */ function close() {
        const closeMatch = /^}/.exec(css);
        if (closeMatch) {
            processMatch(closeMatch);
            return true;
        }
        return false;
    }
    /**
   * Parse ruleset.
   */ function rules() {
        let node;
        const rules = [];
        whitespace();
        comments(rules);
        while(css.length && css.charAt(0) !== '}' && (node = atrule() || rule()))if (node) {
            rules.push(node);
            comments(rules);
        }
        return rules;
    }
    /**
   * Update position and css string. Return the matches
   */ function processMatch(m) {
        const str = m[0];
        updatePosition(str);
        css = css.slice(str.length);
        return m;
    }
    /**
   * Parse whitespace.
   */ function whitespace() {
        const m = /^\s*/.exec(css);
        if (m) processMatch(m);
    }
    /**
   * Parse comments;
   */ function comments(rules) {
        let c;
        rules = rules || [];
        while(c = comment())if (c) rules.push(c);
        return rules;
    }
    /**
   * Parse comment.
   */ function comment() {
        const pos = position();
        if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) return;
        const m = /^\/\*[^]*?\*\//.exec(css);
        if (!m) return error('End of comment missing');
        processMatch(m);
        return pos({
            type: (0, $b2e137848b48cf4f$export$9be5dd6e61d5d73a).comment,
            comment: m[0].slice(2, -2)
        });
    }
    /**
   * Parse selector.
   */ function selector() {
        const m = /^([^{]+)/.exec(css);
        if (!m) return;
        processMatch(m);
        // remove comment in selector;
        const res = $d708735ed1303b43$var$trim(m[0]).replace($d708735ed1303b43$var$commentre, '');
        return (0, $6d129ebf064c486f$export$801dd37ac183521b)(res, [
            ','
        ]).map((v)=>$d708735ed1303b43$var$trim(v));
    }
    /**
   * Parse declaration.
   */ function declaration() {
        const pos = position();
        // prop
        const propMatch = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/.exec(css);
        if (!propMatch) return;
        processMatch(propMatch);
        const propValue = $d708735ed1303b43$var$trim(propMatch[0]);
        // :
        const sepratotorMatch = /^:\s*/.exec(css);
        if (!sepratotorMatch) return error("property missing ':'");
        processMatch(sepratotorMatch);
        // val
        let value = '';
        const endValuePosition = (0, $6d129ebf064c486f$export$b8d42a8583d2e477)(css, [
            ';',
            '}'
        ]);
        if (endValuePosition !== -1) {
            value = css.substring(0, endValuePosition);
            const fakeMatch = [
                value
            ];
            processMatch(fakeMatch);
            value = $d708735ed1303b43$var$trim(value).replace($d708735ed1303b43$var$commentre, '');
        }
        const ret = pos({
            type: (0, $b2e137848b48cf4f$export$9be5dd6e61d5d73a).declaration,
            property: propValue.replace($d708735ed1303b43$var$commentre, ''),
            value: value
        });
        // ;
        const endMatch = /^[;\s]*/.exec(css);
        if (endMatch) processMatch(endMatch);
        return ret;
    }
    /**
   * Parse declarations.
   */ function declarations() {
        const decls = [];
        if (!open()) return error("missing '{'");
        comments(decls);
        // declarations
        let decl;
        while(decl = declaration())if (decl) {
            decls.push(decl);
            comments(decls);
        }
        if (!close()) return error("missing '}'");
        return decls;
    }
    /**
   * Parse keyframe.
   */ function keyframe() {
        let m;
        const vals = [];
        const pos = position();
        while(m = /^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/.exec(css)){
            const res = processMatch(m);
            vals.push(res[1]);
            const spacesMatch = /^,\s*/.exec(css);
            if (spacesMatch) processMatch(spacesMatch);
        }
        if (!vals.length) return;
        return pos({
            type: (0, $b2e137848b48cf4f$export$9be5dd6e61d5d73a).keyframe,
            values: vals,
            declarations: declarations() || []
        });
    }
    /**
   * Parse keyframes.
   */ function atkeyframes() {
        const pos = position();
        const m1 = /^@([-\w]+)?keyframes\s*/.exec(css);
        if (!m1) return;
        const vendor = processMatch(m1)[1];
        // identifier
        const m2 = /^([-\w]+)\s*/.exec(css);
        if (!m2) return error('@keyframes missing name');
        const name = processMatch(m2)[1];
        if (!open()) return error("@keyframes missing '{'");
        let frame;
        let frames = comments();
        while(frame = keyframe()){
            frames.push(frame);
            frames = frames.concat(comments());
        }
        if (!close()) return error("@keyframes missing '}'");
        return pos({
            type: (0, $b2e137848b48cf4f$export$9be5dd6e61d5d73a).keyframes,
            name: name,
            vendor: vendor,
            keyframes: frames
        });
    }
    /**
   * Parse supports.
   */ function atsupports() {
        const pos = position();
        const m = /^@supports *([^{]+)/.exec(css);
        if (!m) return;
        const supports = $d708735ed1303b43$var$trim(processMatch(m)[1]);
        if (!open()) return error("@supports missing '{'");
        const style = comments().concat(rules());
        if (!close()) return error("@supports missing '}'");
        return pos({
            type: (0, $b2e137848b48cf4f$export$9be5dd6e61d5d73a).supports,
            supports: supports,
            rules: style
        });
    }
    /**
   * Parse host.
   */ function athost() {
        const pos = position();
        const m = /^@host\s*/.exec(css);
        if (!m) return;
        processMatch(m);
        if (!open()) return error("@host missing '{'");
        const style = comments().concat(rules());
        if (!close()) return error("@host missing '}'");
        return pos({
            type: (0, $b2e137848b48cf4f$export$9be5dd6e61d5d73a).host,
            rules: style
        });
    }
    /**
   * Parse container.
   */ function atcontainer() {
        const pos = p